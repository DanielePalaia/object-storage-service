# Object Storage Service

A simple HTTP service in Go for storing, retrieving, and deleting objects by bucket and object ID. Objects are stored in-memory with support for deduplication within buckets.

---

## Features

- REST API with endpoints to upload, download, and delete objects
- Deduplication of objects within the same bucket
- Configurable server port
- In-memory storage implementation (extensible for other storage backends)
- Swagger/OpenAPI documentation included
- Tested with unit and integration tests
- Dockerized for easy deployment (ex Kubernetes)

---

## Project Structure

```
.
├── api                 # HTTP handlers, server setup, routing
├── domain              # Core business logic and storage interfaces
├── persistence         # Storage implementations (in-memory)
├── docs                # Swagger docs generated by swaggo
├── main.go             # Application entry point
├── Dockerfile          # Container build configuration
├── Makefile            # Build, run, test automation
├── go.mod              # Go modules dependencies
├── go.sum
└── README.md
```

---

## Installation & Setup

### Prerequisites

- Go 1.23 or higher
- Docker

---

## Running the Service

### With Makefile

Run the service locally:

```bash
make run
```

Run the service with Docker:

```bash
make docker-run
```

Run tests:

```bash
make test
```

Clean up build artifacts:

```bash
make clean
```

---

## Swagger UI

Swagger UI is available at:

```
http://localhost:8080/swagger/index.html
```

---

## API Endpoints

| Method | Endpoint                    | Description                  | Response Status         |
|--------|-----------------------------|------------------------------|------------------------|
| PUT    | `/objects/{bucket}/{objectID}` | Upload and updatean object   | 201 Created            |
| GET    | `/objects/{bucket}/{objectID}` | Download an object           | 200 OK or 404 Not Found |
| DELETE | `/objects/{bucket}/{objectID}` | Delete an object             | 200 OK or 404 Not Found |

**Basic Observability** Also a basic /health entrypoint has been provided in order to check for the state of the service (useful for a load balancer for example or for generic status check)

**For Not found in the spec was specified to use 400 but actually 404 is more appropriate**

---

## Extensions and future improvements

### 🔄 CI/CD

Planned integration via GitHub Actions: This is the first thing I would do in order to test the codebase on new PRs and new code and maybe publish in a docker registry in order eventually to be run in a Kubernetes deployment and scale.
- ✅ `go fmt` formatting checks
- ✅ `go vet` and vulnerability scan (`govulncheck`)
- ✅ Unit test execution with coverage
- ✅ Docker image build & push to Docker Hub

### 💾 Persistence

- Replace in-memory store with **Redis** or **PostgreSQL**: At the moment the project is implementing with a GO map which is not ideal at all. I just used this approach to save time. Better to replace it with an external datastore in order to make the microservice stateless and allow them to scale more and manage concourrency.

### 📈 Observability

- Integrate **Prometheus** metrics (like number of requests validated or failed). A new /metrics endpoint will be needed together with the integration of the Prometheus API.
- Add **OpenTelemetry** tracing for request flows always more requested by customers and Open source community

### ⚙️ Scalability

- Container orchestration with **Kubernetes** / improving datastore to be fully stateless. Deployment can be automated by a github action or using gitops tools (ex. ArgoCD)

## Use of AI Tools

I used chatgtp in order to be more efficient on some of the work:

- Swagger integration with annotations
- Creation of Makefile and Dockerfile
- First draft on the unit/integration tests
- Some verifications after the project was implemented to see if specs were complied.

In general I just asked for support to increase productivity keeping implementation in my control

---

## License

MIT License
